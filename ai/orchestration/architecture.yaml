# ============================================================================
# Orchestration Architecture — Atlasia AI Pipeline
# ============================================================================
# Defines the hybrid orchestration pattern: a sequential pipeline base with
# graph-based retry loops and hierarchical delegation for code review.
#
# This is NOT a single pattern — it is a deliberate hybrid that uses the
# right coordination model at each stage of the workflow.
# ============================================================================

version: "2.0"

# ---------------------------------------------------------------------------
# Pattern Selection Rationale
# ---------------------------------------------------------------------------
# The Atlasia pipeline uses FIVE orchestration patterns in concert:
#
# 1. SEQUENTIAL (Pipeline) — The backbone. Deterministic flow from PM to Writer.
#    Easiest to debug, trace, and reason about. Each step produces a structured
#    artifact consumed by the next.
#
# 2. GRAPH (State Machine) — For retry loops. When the Tester finds failures,
#    the workflow loops back to the Developer, not forward to the Writer.
#    Edges are conditional: success → forward, failure → loop-back.
#
# 3. HIERARCHICAL (Supervisor) — For code review. The Review agent is a
#    supervisor that delegates to four specialist review roles (Security Engineer,
#    Code Quality Engineer, SRE Engineer, Frontend UX Engineer) and synthesizes
#    their output. The orchestrator never talks to reviewers directly.
#
# 4. CRITIC LOOP (Dual-Agent Verification) — The agent that writes should
#    never be the sole agent that verifies. Separate creation from evaluation
#    with bounded feedback loops and conflict resolution.
#
# 5. TASK LEDGER (Execution Planning) — Before dispatching any agent, the
#    orchestrator generates a plan (task_ledger.json) listing every intended
#    step. This ledger is the "shared brain" of the team.
#
# This hybrid avoids the chaos of a pure network topology while allowing
# the flexibility needed for real software engineering workflows.

architecture:
  name: "Hybrid Sequential-Graph-Hierarchical-Critic-Ledger"
  description: >
    A five-layer orchestration architecture combining the predictability of a
    linear pipeline, the resilience of graph-based retry loops, the depth of
    hierarchical multi-perspective review, the reliability of dual-agent
    critic loops with conflict resolution, and the transparency of a shared
    task ledger for execution planning and observability.

  # -------------------------------------------------------------------------
  # Layer 1: Sequential Pipeline (The Backbone)
  # -------------------------------------------------------------------------
  sequential_pipeline:
    description: >
      The default flow. Tasks move linearly from PM to Writer. Each agent
      reads the artifact from the previous step and produces the artifact
      for the next. No agent can skip a step or jump ahead.
    flow:
      - { node: pm,        produces: "ticket_plan.json",         next: qualifier }
      - { node: qualifier,  produces: "work_plan.json",           next: architect }
      - { node: architect,  produces: "architecture_notes.md",    next: developer }
      - { node: developer,  produces: "implementation_report.md", next: review }
      - { node: review,     produces: "persona_review.json",      next: [tester, developer] }
      - { node: tester,     produces: "test_report.json",         next: [writer, developer] }
      - { node: writer,     produces: "docs_patch",               next: null }
    invariants:
      - "Agents execute in strict order unless a graph edge reroutes the flow."
      - "Each transition is gated by artifact schema validation and quality checks."
      - "The orchestrator tracks progress via the Correlation ID."

  # -------------------------------------------------------------------------
  # Layer 2: Graph-Based Retry Loops (Conditional Edges)
  # -------------------------------------------------------------------------
  graph_loops:
    description: >
      When an agent detects a failure that requires rework, the workflow loops
      back to the responsible agent instead of proceeding forward. These loops
      are bounded by max_iterations to prevent infinite cycles.
    edges:
      review_to_developer:
        from: review
        to: developer
        condition: "persona_review.json status is 'changes_required' or 'rejected'"
        description: >
          If the review agent finds critical/high findings, the workflow routes
          back to the developer with the persona_review.json as additional input.
          The developer addresses the findings and re-submits.
        max_iterations: 2
        on_limit_exceeded: "escalation"
        context_passed:
          - "persona_review.json (findings only, not full conversation)"
          - "implementation_report.md (original, for reference)"
        context_excluded:
          - "Persona internal reasoning traces"
          - "Review agent's chain-of-thought"

      tester_to_developer:
        from: tester
        to: developer
        condition: "test_report.json ciStatus is 'RED' AND fix_loop iterations exhausted"
        description: >
          If the tester's internal fix loop cannot resolve failures (CI: 3 tries,
          E2E: 2 tries), the workflow escalates to the developer with the full
          diagnostic report. The developer addresses root causes and re-submits.
        max_iterations: 2
        on_limit_exceeded: "escalation"
        context_passed:
          - "test_report.json (failure diagnostics and root cause analysis)"
          - "Specific failing test names and error traces"
        context_excluded:
          - "Full CI log output (summarized in test_report)"
          - "Tester's internal fix attempts"

    state_machine:
      description: >
        The workflow is modeled as a finite state machine where each agent is
        a state and transitions are edges. Forward edges are unconditional
        (on success). Loop-back edges are conditional (on failure). Terminal
        states: writer (success), escalation (human needed).
      states:
        pm: { type: "sequential", forward: "qualifier" }
        qualifier: { type: "sequential", forward: "architect" }
        architect: { type: "sequential", forward: "developer" }
        developer: { type: "sequential", forward: "review" }
        review:
          type: "conditional"
          forward: "tester"
          loop_back: { target: "developer", condition: "changes_required OR rejected" }
        tester:
          type: "conditional"
          forward: "writer"
          loop_back: { target: "developer", condition: "ci_red AND fix_loop_exhausted" }
        writer: { type: "terminal", forward: null }
        escalation: { type: "terminal", forward: null }
      transitions:
        description: >
          Every state transition is logged as a structured record conforming to
          state_transition.schema.json. This provides a complete audit trail.
        schema: "ai/schemas/state_transition.schema.json"
        rules:
          - "Every transition logs: {from, to, type, reason, artifact_id, correlation_id, timestamp}."
          - "Loop-back transitions increment a counter per edge."
          - "If any edge counter exceeds max_iterations, transition to 'escalation' instead."
          - "Forward transitions require artifact schema validation BEFORE the transition is committed."
          - "Gate transitions (gate_pause, gate_resume) record human decisions."
        valid_transition_matrix:
          pm: ["qualifier"]
          qualifier: ["architect"]
          architect: ["developer"]
          developer: ["review"]
          review: ["tester", "developer"]
          tester: ["writer", "developer"]
          writer: []
          escalation: []
        enforcement: >
          The orchestrator validates every transition against the valid_transition_matrix.
          Any transition not in the matrix is rejected with an error. This prevents
          skip-ahead and ensures the pipeline follows the declared topology.

  # -------------------------------------------------------------------------
  # Layer 3: Hierarchical Delegation (Supervisor Pattern)
  # -------------------------------------------------------------------------
  hierarchical_delegation:
    description: >
      The Review agent acts as a supervisor, delegating work to four specialist
      review roles. The orchestrator dispatches to the Review agent; the Review
      agent internally fans out to reviewers and synthesizes results. The
      orchestrator never interacts with reviewers directly.
    supervisor: review
    delegates:
      - { reviewer: security-engineer,       role: "Security Review",       parallel: true }
      - { reviewer: code-quality-engineer,   role: "Code Quality Review",   parallel: true }
      - { reviewer: sre-engineer,            role: "Infrastructure Review", parallel: true }
      - { reviewer: frontend-ux-engineer,    role: "Frontend UX Review",    parallel: true }
    protocol:
      - "The supervisor receives the PR diff and fans out to all four specialist reviewers in parallel."
      - "Each reviewer receives ONLY: the PR diff, their scoped MCP connections, and the review checklist."
      - "Each reviewer produces: a list of findings with severity, location, description, and suggested fix."
      - "The supervisor collects, deduplicates, ranks, and synthesizes findings into persona_review.json."
      - "The supervisor determines the overall verdict: approved, approved_with_minor_issues, changes_required, rejected."
    context_isolation:
      - "Reviewers do NOT see each other's findings during review."
      - "Reviewers do NOT see the full conversation history — only the PR diff and their checklist."
      - "The supervisor does NOT forward reviewer internal reasoning to the orchestrator."

  # -------------------------------------------------------------------------
  # Layer 4: Critic Loop (Dual-Agent Verification)
  # -------------------------------------------------------------------------
  critic_loop:
    description: >
      The Critic Loop enforces the principle that the agent which WRITES
      should never be the sole agent that VERIFIES. Separate creation from
      evaluation to catch blind spots. Defined in detail in critic_loop.yaml.
    protocol: "ai/orchestration/critic_loop.yaml"
    loops:
      - producer: developer
        critic: review
        artifact: "persona_review.json"
        max_iterations: 2
        resolution: "Escalation to human if unresolved after 2 iterations"
      - producer: developer
        critic: tester
        artifact: "test_report.json"
        max_iterations: 2
        resolution: "Escalation to human if unresolved after 2 iterations"
    conflict_resolution:
      description: >
        When multiple review roles produce contradictory findings, the
        Review supervisor resolves the conflict using a priority-ordered
        strategy chain: severity_hierarchy → domain_authority → arbiter_judgment → human_escalation.
      schema: "ai/schemas/conflict_resolution.schema.json"
      strategies:
        - { name: "severity_hierarchy", automatic: true, description: "Higher severity always wins" }
        - { name: "domain_authority", automatic: true, description: "Domain expert prevails within their specialty" }
        - { name: "arbiter_judgment", automatic: false, description: "Review supervisor weighs positions against quality rubric" }
        - { name: "human_escalation", automatic: false, description: "Unresolvable conflicts escalate to human" }
    guardrails:
      - "No context accumulation across loop iterations"
      - "Focused re-review on iteration 2+ (only verify prior fixes)"
      - "Escalation over persistence — never attempt a 3rd loop"
      - "No self-review — producer cannot certify its own output"
      - "Regression detection on re-review iterations"

  # -------------------------------------------------------------------------
  # Layer 5: Task Ledger (Execution Planning)
  # -------------------------------------------------------------------------
  task_ledger:
    description: >
      Before dispatching any agent, the orchestrator generates a Task Ledger
      (task_ledger.json) that lists every planned step, gate, and artifact.
      This ledger is the "shared brain" of the team — a living document
      updated at every state transition. Defined in detail in task_ledger.yaml.
    protocol: "ai/orchestration/task_ledger.yaml"
    schema: "ai/schemas/task_ledger.schema.json"
    lifecycle:
      - phase: "planning"
        trigger: "Workflow start"
        output: "task_ledger.json + plan.md"
      - phase: "executing"
        trigger: "Every state transition"
        output: "Updated task_ledger.json + plan.md"
      - phase: "terminal"
        trigger: "Workflow completion, escalation, or abort"
        output: "Final task_ledger.json with full audit trail"
    blackboard_entry:
      key: "task_ledger"
      producer: orchestrator
      consumers: ["all agents (read-only)"]
      access: "Only the orchestrator can write; all agents can read"

# ---------------------------------------------------------------------------
# Anti-Patterns — Explicitly Forbidden
# ---------------------------------------------------------------------------
anti_patterns:
  - name: "Full-Context Forwarding"
    description: "Never forward the entire conversation history between agents. Use structured artifacts only."
    violation_action: "The orchestrator strips all non-artifact content from inter-agent messages."

  - name: "Skip-Ahead"
    description: "No agent can skip steps in the pipeline (e.g., PM cannot hand off directly to Developer)."
    violation_action: "The orchestrator rejects any handoff that does not match the declared workflow order."

  - name: "Unbounded Loops"
    description: "Retry loops without max_iterations lead to infinite cycles and runaway costs."
    violation_action: "Every loop-back edge MUST declare max_iterations. Default is 2 if not specified."

  - name: "Direct Reviewer Access"
    description: "The orchestrator must not dispatch directly to specialist reviewers. Always route through the Review supervisor."
    violation_action: "Reviewer agents reject any dispatch not originating from the Review agent."
