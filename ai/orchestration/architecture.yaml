# ============================================================================
# Orchestration Architecture — Atlasia AI Pipeline
# ============================================================================
# Defines the hybrid orchestration pattern: a sequential pipeline base with
# graph-based retry loops and hierarchical delegation for code review.
#
# This is NOT a single pattern — it is a deliberate hybrid that uses the
# right coordination model at each stage of the workflow.
# ============================================================================

version: "3.0"

# ---------------------------------------------------------------------------
# Pattern Selection Rationale
# ---------------------------------------------------------------------------
# The Atlasia pipeline uses NINE orchestration patterns in concert:
#
# 1. SEQUENTIAL (Pipeline) — The backbone. Deterministic flow from PM to Writer.
#    Easiest to debug, trace, and reason about. Each step produces a structured
#    artifact consumed by the next.
#
# 2. GRAPH (State Machine) — For retry loops. When the Tester finds failures,
#    the workflow loops back to the Developer, not forward to the Writer.
#    Edges are conditional: success → forward, failure → loop-back.
#
# 3. HIERARCHICAL (Supervisor) — For code review. The Review agent is a
#    supervisor that delegates to four specialist review roles (Security Engineer,
#    Code Quality Engineer, SRE Engineer, Frontend UX Engineer) and synthesizes
#    their output. The orchestrator never talks to reviewers directly.
#
# 4. CRITIC LOOP (Dual-Agent Verification) — The agent that writes should
#    never be the sole agent that verifies. Separate creation from evaluation
#    with bounded feedback loops and conflict resolution.
#
# 5. TASK LEDGER (Execution Planning) — Before dispatching any agent, the
#    orchestrator generates a plan (task_ledger.json) listing every intended
#    step. This ledger is the "shared brain" of the team.
#
#
# 6. A2A PROTOCOL (Agent Discovery) — Capability-based agent discovery
#    replacing hardcoded routing. Agents publish Agent Cards; the orchestrator
#    matches tasks to the best available agent dynamically.
#
# 7. BLACKBOARD (Shared Memory) — Versioned, access-controlled shared memory
#    store where agents post artifacts and read updates asynchronously. Includes
#    the Progress Ledger for goal/subgoal tracking.
#
# 8. DYNAMIC INTERRUPTS (Runtime Guardrails) — Real-time monitoring of agent
#    actions with tiered interrupt rules (critical/high/medium/low). Blocks
#    destructive operations before they execute.
#
# 9. LLM-AS-A-JUDGE (Quality Arbitration) — Independent Judge agent with veto
#    power, majority voting for high-stakes decisions, and Pass@1 tracking.
#
# This hybrid avoids the chaos of a pure network topology while allowing
# the flexibility needed for real software engineering workflows.

architecture:
  name: "Hybrid Sequential-Graph-Hierarchical-Critic-Ledger-A2A-Blackboard-Interrupt-Judge"
  description: >
    A nine-layer production-grade orchestration architecture combining:
    (1) sequential pipeline predictability, (2) graph-based retry resilience,
    (3) hierarchical multi-perspective review, (4) dual-agent critic loops,
    (5) shared task ledger transparency, (6) A2A protocol for dynamic agent
    discovery, (7) blackboard shared memory for async artifact exchange,
    (8) dynamic interrupts for runtime guardrails, and (9) LLM-as-a-Judge
    quality arbitration with majority voting.

  # -------------------------------------------------------------------------
  # Layer 1: Sequential Pipeline (The Backbone)
  # -------------------------------------------------------------------------
  sequential_pipeline:
    description: >
      The default flow. Tasks move linearly from PM to Writer. Each agent
      reads the artifact from the previous step and produces the artifact
      for the next. No agent can skip a step or jump ahead.
    flow:
      - { node: pm,        produces: "ticket_plan.json",         next: qualifier }
      - { node: qualifier,  produces: "work_plan.json",           next: architect }
      - { node: architect,  produces: "architecture_notes.md",    next: developer }
      - { node: developer,  produces: "implementation_report.md", next: review }
      - { node: review,     produces: "persona_review.json",      next: [tester, developer] }
      - { node: tester,     produces: "test_report.json",         next: [writer, developer] }
      - { node: writer,     produces: "docs_patch",               next: null }
    invariants:
      - "Agents execute in strict order unless a graph edge reroutes the flow."
      - "Each transition is gated by artifact schema validation and quality checks."
      - "The orchestrator tracks progress via the Correlation ID."

  # -------------------------------------------------------------------------
  # Layer 2: Graph-Based Retry Loops (Conditional Edges)
  # -------------------------------------------------------------------------
  graph_loops:
    description: >
      When an agent detects a failure that requires rework, the workflow loops
      back to the responsible agent instead of proceeding forward. These loops
      are bounded by max_iterations to prevent infinite cycles.
    edges:
      review_to_developer:
        from: review
        to: developer
        condition: "persona_review.json status is 'changes_required' or 'rejected'"
        description: >
          If the review agent finds critical/high findings, the workflow routes
          back to the developer with the persona_review.json as additional input.
          The developer addresses the findings and re-submits.
        max_iterations: 2
        on_limit_exceeded: "escalation"
        context_passed:
          - "persona_review.json (findings only, not full conversation)"
          - "implementation_report.md (original, for reference)"
        context_excluded:
          - "Persona internal reasoning traces"
          - "Review agent's chain-of-thought"

      tester_to_developer:
        from: tester
        to: developer
        condition: "test_report.json ciStatus is 'RED' AND fix_loop iterations exhausted"
        description: >
          If the tester's internal fix loop cannot resolve failures (CI: 3 tries,
          E2E: 2 tries), the workflow escalates to the developer with the full
          diagnostic report. The developer addresses root causes and re-submits.
        max_iterations: 2
        on_limit_exceeded: "escalation"
        context_passed:
          - "test_report.json (failure diagnostics and root cause analysis)"
          - "Specific failing test names and error traces"
        context_excluded:
          - "Full CI log output (summarized in test_report)"
          - "Tester's internal fix attempts"

    state_machine:
      description: >
        The workflow is modeled as a finite state machine where each agent is
        a state and transitions are edges. Forward edges are unconditional
        (on success). Loop-back edges are conditional (on failure). Terminal
        states: writer (success), escalation (human needed).
      states:
        pm: { type: "sequential", forward: "qualifier" }
        qualifier: { type: "sequential", forward: "architect" }
        architect: { type: "sequential", forward: "developer" }
        developer: { type: "sequential", forward: "review" }
        review:
          type: "conditional"
          forward: "tester"
          loop_back: { target: "developer", condition: "changes_required OR rejected" }
        tester:
          type: "conditional"
          forward: "writer"
          loop_back: { target: "developer", condition: "ci_red AND fix_loop_exhausted" }
        writer: { type: "terminal", forward: null }
        escalation: { type: "terminal", forward: null }
      transitions:
        description: >
          Every state transition is logged as a structured record conforming to
          state_transition.schema.json. This provides a complete audit trail.
        schema: "ai/schemas/state_transition.schema.json"
        rules:
          - "Every transition logs: {from, to, type, reason, artifact_id, correlation_id, timestamp}."
          - "Loop-back transitions increment a counter per edge."
          - "If any edge counter exceeds max_iterations, transition to 'escalation' instead."
          - "Forward transitions require artifact schema validation BEFORE the transition is committed."
          - "Gate transitions (gate_pause, gate_resume) record human decisions."
        valid_transition_matrix:
          pm: ["qualifier"]
          qualifier: ["architect"]
          architect: ["developer"]
          developer: ["review"]
          review: ["tester", "developer"]
          tester: ["writer", "developer"]
          writer: []
          escalation: []
        enforcement: >
          The orchestrator validates every transition against the valid_transition_matrix.
          Any transition not in the matrix is rejected with an error. This prevents
          skip-ahead and ensures the pipeline follows the declared topology.

  # -------------------------------------------------------------------------
  # Layer 3: Hierarchical Delegation (Supervisor Pattern)
  # -------------------------------------------------------------------------
  hierarchical_delegation:
    description: >
      The Review agent acts as a supervisor, delegating work to four specialist
      review roles. The orchestrator dispatches to the Review agent; the Review
      agent internally fans out to reviewers and synthesizes results. The
      orchestrator never interacts with reviewers directly.
    supervisor: review
    delegates:
      - { reviewer: security-engineer,       role: "Security Review",       parallel: true }
      - { reviewer: code-quality-engineer,   role: "Code Quality Review",   parallel: true }
      - { reviewer: sre-engineer,            role: "Infrastructure Review", parallel: true }
      - { reviewer: frontend-ux-engineer,    role: "Frontend UX Review",    parallel: true }
    protocol:
      - "The supervisor receives the PR diff and fans out to all four specialist reviewers in parallel."
      - "Each reviewer receives ONLY: the PR diff, their scoped MCP connections, and the review checklist."
      - "Each reviewer produces: a list of findings with severity, location, description, and suggested fix."
      - "The supervisor collects, deduplicates, ranks, and synthesizes findings into persona_review.json."
      - "The supervisor determines the overall verdict: approved, approved_with_minor_issues, changes_required, rejected."
    context_isolation:
      - "Reviewers do NOT see each other's findings during review."
      - "Reviewers do NOT see the full conversation history — only the PR diff and their checklist."
      - "The supervisor does NOT forward reviewer internal reasoning to the orchestrator."

  # -------------------------------------------------------------------------
  # Layer 4: Critic Loop (Dual-Agent Verification)
  # -------------------------------------------------------------------------
  critic_loop:
    description: >
      The Critic Loop enforces the principle that the agent which WRITES
      should never be the sole agent that VERIFIES. Separate creation from
      evaluation to catch blind spots. Defined in detail in critic_loop.yaml.
    protocol: "ai/orchestration/critic_loop.yaml"
    loops:
      - producer: developer
        critic: review
        artifact: "persona_review.json"
        max_iterations: 2
        resolution: "Escalation to human if unresolved after 2 iterations"
      - producer: developer
        critic: tester
        artifact: "test_report.json"
        max_iterations: 2
        resolution: "Escalation to human if unresolved after 2 iterations"
    conflict_resolution:
      description: >
        When multiple review roles produce contradictory findings, the
        Review supervisor resolves the conflict using a priority-ordered
        strategy chain: severity_hierarchy → domain_authority → arbiter_judgment → human_escalation.
      schema: "ai/schemas/conflict_resolution.schema.json"
      strategies:
        - { name: "severity_hierarchy", automatic: true, description: "Higher severity always wins" }
        - { name: "domain_authority", automatic: true, description: "Domain expert prevails within their specialty" }
        - { name: "arbiter_judgment", automatic: false, description: "Review supervisor weighs positions against quality rubric" }
        - { name: "human_escalation", automatic: false, description: "Unresolvable conflicts escalate to human" }
    guardrails:
      - "No context accumulation across loop iterations"
      - "Focused re-review on iteration 2+ (only verify prior fixes)"
      - "Escalation over persistence — never attempt a 3rd loop"
      - "No self-review — producer cannot certify its own output"
      - "Regression detection on re-review iterations"

  # -------------------------------------------------------------------------
  # Layer 5: Task Ledger (Execution Planning)
  # -------------------------------------------------------------------------
  task_ledger:
    description: >
      Before dispatching any agent, the orchestrator generates a Task Ledger
      (task_ledger.json) that lists every planned step, gate, and artifact.
      This ledger is the "shared brain" of the team — a living document
      updated at every state transition. Defined in detail in task_ledger.yaml.
    protocol: "ai/orchestration/task_ledger.yaml"
    schema: "ai/schemas/task_ledger.schema.json"
    lifecycle:
      - phase: "planning"
        trigger: "Workflow start"
        output: "task_ledger.json + plan.md"
      - phase: "executing"
        trigger: "Every state transition"
        output: "Updated task_ledger.json + plan.md"
      - phase: "terminal"
        trigger: "Workflow completion, escalation, or abort"
        output: "Final task_ledger.json with full audit trail"
    blackboard_entry:
      key: "task_ledger"
      producer: orchestrator
      consumers: ["all agents (read-only)"]
      access: "Only the orchestrator can write; all agents can read"

  # -------------------------------------------------------------------------
  # Layer 6: A2A Protocol (Agent Discovery & Capability Matching)
  # -------------------------------------------------------------------------
  a2a_protocol:
    description: >
      Implements the Agent-to-Agent (A2A) open standard for dynamic agent
      discovery, replacing hardcoded agent routing. Each agent publishes an
      Agent Card describing capabilities, schemas, and constraints. The
      orchestrator queries the A2A Registry to find the best agent for each
      task based on capability coverage, historical effectiveness, current
      load, and cost efficiency.
    protocol: "ai/protocols/a2a/a2a_protocol.yaml"
    registry: "ai/protocols/a2a/agent_registry.yaml"
    schema: "ai/schemas/agent_card.schema.json"
    key_features:
      - "Capability-based routing (not identity-based)"
      - "Multi-vendor agent support (Anthropic, OpenAI, Google, custom)"
      - "Hot-swapping of agents without pipeline changes"
      - "Scored discovery with tie-breaking"
      - "Backward-compatible: existing Spring beans work without cards"

  # -------------------------------------------------------------------------
  # Layer 7: Blackboard (Shared Memory & Progress Ledger)
  # -------------------------------------------------------------------------
  blackboard:
    description: >
      A versioned, access-controlled shared memory store implementing both
      the Blackboard Pattern (async artifact exchange) and the Magentic
      Progress Ledger (goal/subgoal tracking). Agents post findings and
      read updates without speaking directly — reducing noise and token costs.
    protocol: "ai/orchestration/blackboard.yaml"
    schemas:
      - "ai/schemas/blackboard_entry.schema.json"
      - "ai/schemas/progress_ledger.schema.json"
    key_features:
      - "Strict producer/consumer access control per entry"
      - "Append-only versioning (full history for audit)"
      - "Schema validation on every write"
      - "Redis hot cache for active workflows"
      - "Vector store indexing for historical retrieval"
      - "Progress Ledger with goals, subgoals, blockers, and timeline"

  # -------------------------------------------------------------------------
  # Layer 8: Dynamic Interrupts (Runtime Guardrails)
  # -------------------------------------------------------------------------
  dynamic_interrupts:
    description: >
      Real-time monitoring of every agent tool call against tiered interrupt
      rules. High-risk operations are blocked BEFORE execution. Implements
      least privilege via MCP Roots, secret detection, destructive operation
      prevention, and file scope enforcement.
    protocol: "ai/orchestration/dynamic_interrupts.yaml"
    tiers:
      critical: "Always block — destructive git/SQL, secret exposure"
      high: "Block by default — out-of-scope writes, large changes, new deps"
      medium: "Notify and delay — PR creation, external API calls"
      low: "Log only — token budget warnings, long-running steps"
    key_features:
      - "Pre-execution evaluation of every MCP tool call"
      - "Pattern-based secret detection (API keys, tokens, private keys)"
      - "Protected branch enforcement"
      - "Destructive SQL prevention"
      - "Conflict routing to Judge agent for arbitration"

  # -------------------------------------------------------------------------
  # Layer 9: LLM-as-a-Judge (Quality Arbitration)
  # -------------------------------------------------------------------------
  judge:
    description: >
      Independent quality arbiter with VETO POWER. Evaluates artifacts against
      structured rubrics at defined checkpoints. For high-stakes decisions,
      uses Majority Voting (3 independent evaluations) instead of single-agent
      judgment. Tracks Pass@1 to measure pipeline quality over time.
    agent: "ai/agents/judge.yaml"
    voting_protocol: "ai/orchestration/majority_voting.yaml"
    schema: "ai/schemas/judge_verdict.schema.json"
    checkpoints:
      post_developer: "Advisory evaluation of implementation quality"
      post_review: "Evaluate review quality (actionability, accuracy)"
      pre_merge: "Binding quality gate with veto power"
      conflict_arbitration: "Resolve inter-agent disagreements"
    key_features:
      - "Structured rubric-based evaluation (not subjective)"
      - "Veto power at pre-merge gate"
      - "Majority Voting (3 voters) for high-stakes decisions"
      - "Confidence-weighted synthesis for conflict arbitration"
      - "Pass@1 tracking for regression detection"

# ---------------------------------------------------------------------------
# Anti-Patterns — Explicitly Forbidden
# ---------------------------------------------------------------------------
anti_patterns:
  - name: "Full-Context Forwarding"
    description: "Never forward the entire conversation history between agents. Use structured artifacts only."
    violation_action: "The orchestrator strips all non-artifact content from inter-agent messages."

  - name: "Skip-Ahead"
    description: "No agent can skip steps in the pipeline (e.g., PM cannot hand off directly to Developer)."
    violation_action: "The orchestrator rejects any handoff that does not match the declared workflow order."

  - name: "Unbounded Loops"
    description: "Retry loops without max_iterations lead to infinite cycles and runaway costs."
    violation_action: "Every loop-back edge MUST declare max_iterations. Default is 2 if not specified."

  - name: "Direct Reviewer Access"
    description: "The orchestrator must not dispatch directly to specialist reviewers. Always route through the Review supervisor."
    violation_action: "Reviewer agents reject any dispatch not originating from the Review agent."
