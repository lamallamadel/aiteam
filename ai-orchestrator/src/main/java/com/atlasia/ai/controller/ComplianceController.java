package com.atlasia.ai.controller;

import com.atlasia.ai.service.ComplianceReportService;
import com.atlasia.ai.service.CurrentUserService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.web.bind.annotation.*;

import java.time.Instant;
import java.time.temporal.ChronoUnit;
import java.util.Map;
import java.util.UUID;

@RestController
@RequestMapping("/api/compliance")
public class ComplianceController {

    private static final Logger logger = LoggerFactory.getLogger(ComplianceController.class);

    private final ComplianceReportService complianceReportService;
    private final CurrentUserService currentUserService;

    public ComplianceController(
            ComplianceReportService complianceReportService,
            CurrentUserService currentUserService) {
        this.complianceReportService = complianceReportService;
        this.currentUserService = currentUserService;
    }

    @GetMapping("/export")
    public ResponseEntity<Map<String, Object>> exportUserDataForGDPR(
            @RequestParam(required = false) UUID userId) {
        try {
            UUID targetUserId = userId;
            if (targetUserId == null) {
                targetUserId = currentUserService.getCurrentUserId();
            } else {
                UUID currentUserId = currentUserService.getCurrentUserId();
                
                if (!targetUserId.equals(currentUserId)) {
                    logger.warn("User {} attempted to access GDPR export for user {} without permission", 
                              currentUserId, targetUserId);
                    return ResponseEntity.status(HttpStatus.FORBIDDEN).build();
                }
            }
            
            Map<String, Object> exportData = complianceReportService.exportUserDataForGDPR(targetUserId);
            
            logger.info("GDPR data export generated for user {}", targetUserId);
            return ResponseEntity.ok(exportData);
            
        } catch (SecurityException e) {
            logger.error("Authentication error during GDPR export", e);
            return ResponseEntity.status(HttpStatus.UNAUTHORIZED).build();
        } catch (Exception e) {
            logger.error("Failed to generate GDPR export", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping("/reports/soc2")
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public ResponseEntity<Map<String, String>> generateSOC2Report(
            @RequestParam(required = false) String periodStart,
            @RequestParam(required = false) String periodEnd) {
        try {
            String username = "ADMIN";
            try {
                username = currentUserService.getCurrentUsername();
            } catch (SecurityException e) {
                logger.warn("Could not get current username, using default ADMIN");
            }
            
            Instant start = periodStart != null ? Instant.parse(periodStart) : 
                          Instant.now().minus(30, ChronoUnit.DAYS);
            Instant end = periodEnd != null ? Instant.parse(periodEnd) : Instant.now();
            
            String filePath = complianceReportService.generateSOC2Report(start, end, username);
            
            logger.info("SOC2 report generated by {} for period {} to {}", username, start, end);
            return ResponseEntity.ok(Map.of(
                "status", "success",
                "filePath", filePath,
                "message", "SOC2 report generated successfully"
            ));
            
        } catch (Exception e) {
            logger.error("Failed to generate SOC2 report", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("status", "error", "message", e.getMessage()));
        }
    }

    @PostMapping("/reports/iso27001")
    @PreAuthorize("hasRole('ROLE_ADMIN')")
    public ResponseEntity<Map<String, String>> generateISO27001Report(
            @RequestParam(required = false) String periodStart,
            @RequestParam(required = false) String periodEnd) {
        try {
            String username = "ADMIN";
            try {
                username = currentUserService.getCurrentUsername();
            } catch (SecurityException e) {
                logger.warn("Could not get current username, using default ADMIN");
            }
            
            Instant start = periodStart != null ? Instant.parse(periodStart) : 
                          Instant.now().minus(30, ChronoUnit.DAYS);
            Instant end = periodEnd != null ? Instant.parse(periodEnd) : Instant.now();
            
            String filePath = complianceReportService.generateISO27001Report(start, end, username);
            
            logger.info("ISO 27001 report generated by {} for period {} to {}", username, start, end);
            return ResponseEntity.ok(Map.of(
                "status", "success",
                "filePath", filePath,
                "message", "ISO 27001 report generated successfully"
            ));
            
        } catch (Exception e) {
            logger.error("Failed to generate ISO 27001 report", e);
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                .body(Map.of("status", "error", "message", e.getMessage()));
        }
    }
}
